<!DOCTYPE html>
<html lang="en">
<head>
    <title>HLSL Constant Buffer Packing Rules & Layout Visualizer</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="description" content="Learn HLSL constant buffer packing rules and visualize the memory layout of your own custom cbuffers!" />
    <meta name="robots" content="index, archive" />
    <meta name="keywords" content="HLSL, DirectX, Direct3D, D3D11, D3D12, DX11, DX12, constant buffer, packing rules, struct packing, struct layout, cbuffer" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title" content="HLSL Constant Buffer Packing Rules & Layout Visualizer" />
    <meta property="og:description" content="Learn HLSL constant buffer packing rules and visualize the memory layout of your own custom cbuffers!" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://maraneshi.github.io/HLSL-ConstantBufferLayoutVisualizer/" />
    <meta property="og:image" content="https://maraneshi.github.io/HLSL-ConstantBufferLayoutVisualizer/screen3.png" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="HLSL Constant Buffer Packing Rules & Layout Visualizer" />
    <meta name="twitter:image" content="https://maraneshi.github.io/HLSL-ConstantBufferLayoutVisualizer/screen3.png" />
    <meta name="twitter:description" content="Learn HLSL constant buffer packing rules and visualize the memory layout of your own custom cbuffers!" />
    <meta name="twitter:creator" content="@maraneshi" />
    <meta name="twitter:site" content="@maraneshi" />
    <!-- NOTE: I don't know whether it's worth doing this at all. The W3 image source is there for the squiggly lines in Monaco. -->
    <META HTTP-EQUIV='Content-Security-Policy' CONTENT="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src data: 'self' w3.org/svg/2000;">
    <meta name="google-site-verification" content="ZJ8tLJVKf9I0aKYguit8CTb2jMFPQLpaJhT1YpQ4eNo" />

    <!-- without preload all these scripts are requested serially, incurring network latency every single time -->
    <link rel="modulepreload" href="main.js" />
    <link rel="modulepreload" href="hlsl_monaco.js" />
    <link rel="modulepreload" href="cbuffer_parser.js" />
    <link rel="modulepreload" href="cbuffer_layout.js" />
    <link rel="modulepreload" href="cbuffer_visualizer.js" />

    <!-- preload the most important fonts with higher priority -->
    <link rel="preload" href="fonts/SourceSans3-Regular.ttf.woff2" as="font" type="font/woff2" crossorigin="anonymous">
    <link rel="preload" href="fonts/SourceSans3-Bold.ttf.woff2" as="font" type="font/woff2" crossorigin="anonymous">
    <link rel="preload" href="fonts/SourceSans3-It.ttf.woff2" as="font" type="font/woff2" crossorigin="anonymous">

    <style>
        /* NOTE: standard fonts on different OSes are so wildly different in size that we need to serve our own fonts for consistency */
        @font-face {
            font-family: "Source Sans 3";
            src: local("Source Sans 3"), local("SourceSans3-Regular"), url("fonts/SourceSans3-Regular.ttf.woff2");
            font-display: block; /* wait until font is loaded */
        }

        @font-face {
            font-family: "Source Sans 3";
            src: local("Source Sans 3 Bold"), local("SourceSans3-Bold"), url("fonts/SourceSans3-Bold.ttf.woff2");
            font-weight: bold;
            font-display: block; /* wait until font is loaded */
        }

        @font-face {
            font-family: "Source Sans 3";
            src: local("Source Sans 3 Italic"), local("SourceSans3-It"), url("fonts/SourceSans3-It.ttf.woff2");
            font-style: italic;
            font-display: block; /* wait until font is loaded */
        }

        @font-face {
            font-family: "Source Code Pro";
            src: local("Source Code Pro"), local("SourceCodePro-Regular"), url("fonts/SourceCodePro-Regular.ttf.woff2");
            font-display: block; /* wait until font is loaded */
        }

        @font-face {
            font-family: "Source Code Pro";
            src: local("Source Code Pro Bold"), local("SourceCodePro-Bold"), url("fonts/SourceCodePro-Bold.ttf.woff2");
            font-weight: bold;
            font-display: block; /* wait until font is loaded */
        }

        :root {
            font-family: "Source Sans 3", sans-serif;
            font-size: 18px;
        }

        .code {
            font-family: "Source Code Pro", monospace;
            font-size: 14px;
            white-space: pre;
        }

        code {
            font-family: "Source Code Pro", monospace;
            white-space: pre;
            background-color: #EEEEEE;
            font-size: 0.94em; /* more in line with surrounding text */
            display: inline-block; /* disable text justification */
        }

        .resizer {
            background-color: #777777;
            cursor: ew-resize;
            min-height: 100%;
            min-width: 2px;
            width: 2px;
            padding: 8px;
            background-clip: content-box;
        }

        .resizer_vert {
            background-color: #777777;
            cursor: ns-resize;
            min-width: 100%;
            min-height: 2px;
            height: 2px;
            padding: 8px;
            background-clip: content-box;
        }

        #main_article p, #main_article i, .list_justified_spaced li {
            line-height: 1.4;
            text-align: justify;
        }

        .list_justified_spaced li {
            margin-block-end: 0.5em;
        }

        sup {
            line-height: 100%;
            font-size: 0.89em;
            vertical-align: top;
        }

        a {
            text-decoration: none;
        }

            a:hover {
                text-decoration: underline;
            }

        #CBV_root_container, .CBV_example_container {
            font-size: initial;
            line-height: initial;
        }

        h4 {
            margin-block-start: 0.5em;
            margin-block-end: 0.5em;
        }

        h3 {
            font-size: 1.25em;
        }

        .rule_definition {
            color: #2d14ad;
            /*padding-top: 16px;*/
        }

            .rule_definition code {
                background-color: #eff4ff;
            }

        .keyword {
            color: #0000ff;
        }

        .bracket0 {
            color: #0431fa;
        }

        .bracket1 {
            color: #319331;
        }

        .bracket2 {
            color: #7b3814;
        }

        .number {
            color: #098658;
        }

        .CBV_example {
            width: calc(100% - 18px);
            padding: 8px;
            border-top: 2px solid #777777;
            border-bottom: 2px solid #777777;
            border-radius: 12px;
        }

        .CBV_left {
            flex: auto;
            margin-left: 8px;
            margin-right: 8px;
        }

        .CBV_middle {
            flex: auto;
            margin-left: 8px;
            /*margin-right: 8px;*/
            margin-right: 16px; /* includes margin from CBV_right, better for mobile layout */
        }

        .CBV_right {
            flex: 1; /* this effectively aligns it to the right side */
            /*margin-left: 8px;*/
            margin-top: 8px;
        }

        .CBV_example_container {
            margin-left: -8px; /* strip padding for mobile layout */
            margin-top: -8px; /* looks more consistent with the above */
            display: flex;
            overflow: auto;
            width: calc(100% + 8px);
            flex-wrap: wrap;
        }

        dfn {
            font-weight: bold;
            font-style: normal;
        }

        var {
            font-weight: normal;
            font-style: normal;
            font-family: math;
        }

        body {
            counter-reset: footnote;
        }

        a[href^="#fn"] ::after {
            counter-increment: footnote;
            content: counter(footnote)
        }

        .article_width {
            margin: 0px auto;
            width: 60em;
            max-width: 100%;
        }

        input {
            vertical-align: middle;
        }

        output {
            vertical-align: middle;
        }

        label {
            line-height: 1.4;
        }

        button {
            min-height: 2.2em;
            font-family: Arial, sans-serif;
        }
    </style>
    <style title="CBV Dark Theme">
        /* based on VS-Dark from Monaco */
        :root {
            color: rgb(212, 212, 212);
            background-color: rgb(30, 30, 30);
        }

        input {
            color: rgb(204, 204, 204);
            background-color: rgb(60, 60, 60);
            border-color: rgb(118, 118, 118);
        }

        button {
            color: rgb(255, 255, 255);
            background-color: rgb(14, 99, 156);
            border-color: rgb(118, 118, 118);
        }

        code {
            background-color: #363636;
        }

        .rule_definition {
            color: #A0A0F4;
        }

            .rule_definition code {
                background-color: #251960;
                color: #b3b3ff;
            }

        a {
            color: #4e94de;
        }

        .keyword {
            color: #569cd6;
        }

        .bracket0 {
            color: #ffd700;
        }

        .bracket1 {
            color: #da70d6;
        }

        .bracket2 {
            color: #179fff;
        }

        .number {
            color: #b5cea8;
        }
    </style>
</head>
<body>
    <main>
        <!-- for search engines to not complain -->
        <h1 hidden>HLSL Constant Buffer Packing Rules & Layout Visualizer</h1>
        <article>
            <div style="margin: 0px auto; width:fit-content; max-width:100%">
                <h2 style="margin-left:auto; margin-right:auto; width:fit-content">HLSL Constant Buffer Layout Visualizer</h2>
                <div id="CBV_enable_div" style="background-image: url(screen1a.png); background-position: center top; width: 99vw; max-width: 100%; height: 146px; margin-bottom: -24px; background-repeat: no-repeat;">
                    <button id="CBV_enable_button" type="button" style="width: 17em; height: 6em; font-size: 1.1em; margin:auto; display:block; max-width:100%" disabled
                            onclick="CBV_Initialize(); this.disabled = true; this.textContent = 'Loading...'">
                        Click to Load Visualizer
                    </button>
                </div>
            </div>
            <div id="CBV_root_container" style="margin: 0px auto;  max-width:100%" hidden>
                <div style="width: 100%; display: flex; justify-content: center;">
                    <div style="float: left; flex: 0; flex-basis: auto; min-width: 21em; width:25em;">
                        <form action="javascript:CBV_VisualizeCBuffer()">
                            <div id="CBV_editor_container" style="width:100%; min-height:12em"></div>
                            <div class="resizer_vert" id="CBV_resizer_vert"></div>
                            <div>
                                <button type="submit" style="margin-right:4px;">Parse</button>
                                <label for="CBV_auto_parse_delay">Auto-Parse Delay:</label>
                                <input type="range" id="CBV_auto_parse_delay" min="100" max="1500" step="50" value="500" autocomplete="off" style="width:90px;"
                                       oninput="if (this.valueAsNumber == this.getAttribute('max')) CBV_auto_parse_delay_value.value = 'off'; else CBV_auto_parse_delay_value.value = this.value + 'ms';" />
                                <output id="CBV_auto_parse_delay_value"></output>
                                <script>CBV_auto_parse_delay_value.value = CBV_auto_parse_delay.value + 'ms';</script>
                                <br />
                                <input type="text" id="CBV_Shareable_URL" readonly style="width:calc(100% - 8px); margin: 4px 0px 4px 0px;" autocomplete="off" />
                                <br />
                                <button type="button" onclick="window.CBV_Create_Shareable_URL();">Create Shareable Link</button>
                                <button style="float:right" type="button" onclick="navigator.clipboard.writeText(CBV_Shareable_URL.value);">Copy Link</button>
                                <br />
                                <label for="CBV_matches_c_layout">Matches C Layout<a href="#c_layout_notes"><b>*</b></a></label>
                                <output id="CBV_matches_c_layout">❌</output>
                                <br />
                                <label for="CBV_show_c_layout">Show C Layout<a href="#c_layout_notes"><b>*</b></a></label>
                                <input type="checkbox" id="CBV_show_c_layout" autocomplete="off" onchange="window.CBV_VisualizerObject?.SetForceCLayout(this.checked);" />
                                <br />
                                <label for="CBV_hex_offsets">Hexadecimal Offsets</label>
                                <input type="checkbox" id="CBV_hex_offsets" autocomplete="off" onchange="window.CBV_VisualizerObject?.SetSVGHexOffsets(this.checked); window.CBV_ExampleVisualizers?.SetSVGHexOffsets(this.checked);" />
                                <br />
                                <label for="CBV_expanded_arrays">Expanded Arrays</label>
                                <input type="checkbox" id="CBV_expanded_arrays" checked autocomplete="off" onchange="window.CBV_VisualizerObject?.SetExpandedArrays(this.checked);" />
                                <br />
                                <label for="CBV_text_alignment">Offset Text Alignment:</label>
                                <input type="number" id="CBV_text_alignment" value="6" min="1" max="32" style="width:2.65em;" autocomplete="off" oninput="window.CBV_VisualizerObject?.SetTextAlignmentOffset(this.valueAsNumber);" />
                                <br />
                                <label for="CBV_text_indent_width">Indent Width:</label>
                                <input type="number" id="CBV_text_indent_width" value="4" min="1" max="8" style="width:2.65em;" autocomplete="off" oninput="window.CBV_VisualizerObject?.SetTextIndentWidth(this.valueAsNumber);" />
                                <br />
                                <label for="CBV_color_shuffle">Shuffle Colors</label>
                                <input type="checkbox" id="CBV_color_shuffle" autocomplete="off" onchange="window.CBV_VisualizerObject?.SetColorShuffle(this.checked);" />
                                <br />
                                <label for="CBV_color_shuffle_subdivisions">Color Shuffle Subdivisions:</label>
                                <input type="number" id="CBV_color_shuffle_subdivisions" value="4" min="1" max="10" style="width:2.65em" autocomplete="off" oninput="window.CBV_VisualizerObject?.SetColorShuffleSubdivisions(this.valueAsNumber);" />
                                <br />
                                <div id="CBV_color_theme_controls_visualizer_container">
                                    <div id="CBV_color_theme_controls">
                                        <label for="CBV_color_lightness">Color Lightness:</label>
                                        <input type="range" id="CBV_color_lightness" min="0.01" max="1.0" step="0.01" value="0.60" autocomplete="off"
                                               oninput="CBV_color_lightness_value.value = this.value; window.CBV_VisualizerObject?.SetColorLightness(this.valueAsNumber); window.CBV_ExampleVisualizers?.SetColorLightness(this.valueAsNumber);" />
                                        <output id="CBV_color_lightness_value"></output>
                                        <script>CBV_color_lightness_value.value = CBV_color_lightness.value;</script>
                                        <br />
                                        <label for="CBV_color_saturation">Color Saturation:</label>
                                        <input type="range" id="CBV_color_saturation" min="0.01" max="1.0" step="0.01" value="0.60" autocomplete="off"
                                               oninput="CBV_color_saturation_value.value = this.value; window.CBV_VisualizerObject?.SetColorSaturation(this.valueAsNumber); window.CBV_ExampleVisualizers?.SetColorSaturation(this.valueAsNumber);" />
                                        <output id="CBV_color_saturation_value"></output>
                                        <script>CBV_color_saturation_value.value = CBV_color_saturation.value;</script>
                                        <br />
                                        <label for="CBV_color_hue_start">Hue Start:</label>
                                        <input type="range" id="CBV_color_hue_start" min="0" max="359" step="1" value="290" autocomplete="off"
                                               oninput="CBV_color_hue_start_value.value = this.value; window.CBV_VisualizerObject?.SetColorHueStart(this.valueAsNumber); window.CBV_ExampleVisualizers?.SetColorHueStart(this.valueAsNumber);" />
                                        <output id="CBV_color_hue_start_value"></output>
                                        <script>CBV_color_hue_start_value.value = CBV_color_hue_start.value;</script>
                                        <br />
                                        <label for="CBV_color_hue_range">Hue Range:</label>
                                        <input type="range" id="CBV_color_hue_range" min="0" max="360" step="1" value="360" autocomplete="off"
                                               oninput="CBV_color_hue_range_value.value = this.value; window.CBV_VisualizerObject?.SetColorHueRange(this.valueAsNumber); window.CBV_ExampleVisualizers?.SetColorHueRange(this.valueAsNumber);" />
                                        <output id="CBV_color_hue_range_value"></output>
                                        <script>CBV_color_hue_range_value.value = CBV_color_hue_range.value;</script>
                                        <br />
                                        <label for="CBV_dark_theme">Dark Theme</label>
                                        <input type="checkbox" id="CBV_dark_theme" autocomplete="off" onchange="window.CBV_SetDarkTheme(this.checked);" checked />
                                    </div>
                                </div>
                                <p>
                                    <b>Supported Keywords:</b><br />
                                    <span id="CBV_keywords_text" class="code" style="white-space:pre-wrap"></span>
                                </p>
                                <p id="c_layout_notes" style="margin-bottom: 4px;">
                                    <b>* Note:</b> C layout is based on the Structured Buffer layout rules, which are outlined in <a href="#Structured_Buffers">this section at the end of the article</a>.
                                    It assumes a "reasonable" modern platform where the following applies:<br />
                                </p>
                                    <ul style="margin-top: 4px; margin-bottom: 2px; padding-left: 24px;">
                                        <li><code>int</code>, <code>uint</code> and <code>float</code> are 4 bytes, <code>double</code> is 8 bytes</li>
                                        <li>You are using a 4-byte <code>BOOL</code> type instead of the built-in <code>bool</code></li>
                                        <li>All scalar types are self-aligned</li>
                                        <li>Vectors are implemented as simple structs of individual scalars or arrays of scalars, e.g. <code>struct float4 { float x,y,z,w; }</code> or <code>struct float4 { float f[4]; }</code></li>
                                    </ul>
                                <p></p>
                                <div>
                                    <b>Updates:</b><br />
                                    <ul style="margin-top: 2px; margin-bottom: 2px; padding-left: 24px;">
                                        <li>2024-02-05: Structured Buffers are now supported!</li>
                                    </ul>
                                </div>
                            </div>
                        </form>
                    </div>
                    <div class="resizer" id="CBV_resizer_horz"></div>
                    <div style="float: right; display:flex;">
                        <div style="float: left; flex: 1; flex-basis: max-content; padding-right: 8px">
                            <div id="CBV_output_text" class="code">
                            </div>
                        </div>
                        <div style="float: right; flex: 2; flex-basis: max-content; padding-left: 8px;">
                            <svg id="CBV_output_svg" class="code">
                            </svg>
                        </div>
                    </div>
                </div>
            </div>
        </article>

        <script>
            var require = { paths: { vs: 'monaco-editor/min/vs' } };
        </script>

        <script src="lz-string/libs/lz-string.min.js"></script>

        <script type="module">
            import { EnableResizer, ParseHLSLAndVisualizeMonaco, GetSupportedKeywords, SetDarkTheme, CreateMonacoEditor, BufferVisualizerOptionsDefault } from './main.js';

            if (navigator.userAgentData?.mobile ?? /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobi/i.test(navigator.userAgent))
                CBV_enable_button.textContent = "Click to Load Visualizer (unsupported on mobile)";

            window.CBV_Create_Shareable_URL = () => {
                let start = window.performance.now();
                var compressed = LZString.compressToEncodedURIComponent(window.CBV_monaco_editor.getValue());
                let url = location.origin + location.pathname + (location.pathname.endsWith('/') ? '' : '/') + '?visualizer=' + compressed;
                CBV_Shareable_URL.value = url;
                window.performance.measure("Compress URL", { start: start });
            };

            window.CBV_SetDarkTheme = SetDarkTheme;

            window.GetVisualizerOptions = () => {
                let options = Object.assign({}, BufferVisualizerOptionsDefault);
                options.force_c_layout = CBV_show_c_layout.checked;
                options.expanded_arrays = CBV_expanded_arrays.checked;
                options.text_alignment_offset = CBV_text_alignment.valueAsNumber;
                options.text_indent_width = CBV_text_indent_width.valueAsNumber;
                options.color_shuffle = CBV_color_shuffle.checked;
                options.color_shuffle_subdivisions = CBV_color_shuffle_subdivisions.valueAsNumber;
                options.color_lightness = CBV_color_lightness.valueAsNumber;
                options.color_saturation = CBV_color_saturation.valueAsNumber;
                options.color_hue_start = CBV_color_hue_start.valueAsNumber;
                options.color_hue_range = CBV_color_hue_range.valueAsNumber;
                options.svg_hex_offsets = CBV_hex_offsets.checked;
                options.dark_theme = CBV_dark_theme.checked;
                return options;
            }

            EnableResizer(CBV_resizer_horz, false);
            EnableResizer(CBV_resizer_vert, true);

            let keywords_str = "";
            let keywords = GetSupportedKeywords();
            for (let i = 0; i < keywords.length; i++) {
                keywords_str += keywords[i] + ((i != keywords.length - 1) ? ", " : "");
            }
            CBV_keywords_text.append(keywords_str);

            // function to initialize the custom cbuffer visualizer, used by big button
            window.CBV_Initialize = () => {

                let start = window.performance.now();

                // actual initialization of the entire visualizer, delayed until after Monaco editor script load
                const DelayedInit = () => {

                    let start = window.performance.now();

                    window.CBV_monaco_editor = CreateMonacoEditor(CBV_editor_container, window.CBV_URL_Input_String);

                    window.CBV_VisualizeCBuffer = () => {
                        window.CBV_VisualizerObject = ParseHLSLAndVisualizeMonaco(CBV_monaco_editor, CBV_output_text, CBV_output_svg, GetVisualizerOptions());
                    }

                    window.CBV_monaco_editor.getModel().onDidChangeContent(() => {
                        if (CBV_auto_parse_delay.valueAsNumber != CBV_auto_parse_delay.getAttribute("max")) {
                            clearTimeout(window.CBV_parse_timer);
                            window.CBV_parse_timer = setTimeout(CBV_VisualizeCBuffer, CBV_auto_parse_delay.valueAsNumber);
                        }
                    });
                    //window.CBV_monaco_editor.onDidContentSizeChange(() => { // broken
                    //    CBV_editor_container.style.height = `calc(max(${CBV_monaco_editor.getContentHeight() + 'px'}, ${CBV_editor_container.style.height}))`;
                    //});

                    CBV_color_theme_controls_visualizer_container.appendChild(CBV_color_theme_controls);
                    let text = document.createElement("i");
                    text.append("If you have trouble reading the examples, color and theme controls are in the big visualizer above.");
                    CBV_color_theme_controls_inline_container.replaceChildren(text);

                    CBV_VisualizeCBuffer();
                    CBV_enable_div.remove();
                    CBV_root_container.removeAttribute("hidden");

                    window.performance.measure("DelayedInit", { start: start });
                }

                // first, we preload the script/CSS data in parallel so we don't incur network latency for every single file sequentially

                const Preload = (file, type) => {
                    let link = document.createElement('link');
                    link.rel = "preload";
                    link.href = file;
                    link.as = type;
                    if (type == "font" || type == "fetch")
                        link.setAttribute("crossOrigin", "");
                    document.head.appendChild(link);
                };
                Preload("monaco-editor/min/vs/editor/editor.main.css", "style");
                Preload("monaco-editor/min/vs/loader.js", "script");
                Preload("monaco-editor/min/vs/editor/editor.main.nls.js", "script");
                Preload("monaco-editor/min/vs/editor/editor.main.js", "script");
                Preload("monaco-editor/min/vs/base/browser/ui/codicons/codicon/codicon.ttf", "font");
                //Preload("monaco-editor/min/vs/base/worker/workerMain.js", "script"); // this doesn't work for unknown reasons
                //Preload("monaco-editor/min/vs/base/common/worker/simpleWorker.nls.js", "fetch"); // this doesn't work for unknown reasons


                // then we try to actually load/execute the scripts/css

                const LoadScript = (file, callback) => {
                    let script = document.createElement('script');
                    script.src = file;
                    if (callback)
                        script.onload = callback;
                    document.body.appendChild(script);
                };

                const LoadCSS = (file, data_name) => {
                    let link = document.createElement('link');
                    link.rel = "stylesheet";
                    link["data-name"] = data_name;
                    link.href = file;
                    document.head.appendChild(link);
                };

                LoadCSS("monaco-editor/min/vs/editor/editor.main.css", "vs/editor/editor.main");

                // HACK: prevent race condition by loading/executing sequentially
                LoadScript("monaco-editor/min/vs/loader.js",
                    () => LoadScript("monaco-editor/min/vs/editor/editor.main.nls.js",
                        () => LoadScript("monaco-editor/min/vs/editor/editor.main.js", DelayedInit)));

                window.performance.measure("CBV_Initialize", { start: start });
            }

            CBV_color_theme_controls_inline_container.appendChild(CBV_color_theme_controls);

            CBV_enable_button.removeAttribute("disabled"); // only enable the button once the function it calls actually exists

            const params = new URLSearchParams(window.location.search);
            if (params.has("visualizer")) {
                let encoded_string = params.get("visualizer");
                if (encoded_string && encoded_string != "") {
                    try {
                        let start = window.performance.now();
                        window.CBV_URL_Input_String = LZString.decompressFromEncodedURIComponent(encoded_string);
                        window.performance.measure("Decompress URL", { start: start });
                        if (!window.CBV_URL_Input_String || window.CBV_URL_Input_String == "")
                            console.log("ERROR: Failed to decode visualizer input in URL");
                    } catch (e) {
                        console.log("ERROR: Failed to decode visualizer input in URL"); // this should never throw, but just in case
                    }
                }
                CBV_enable_button.click();
            }

        </script>

        <article id="main_article">
            <div style="margin: 0px auto; width:fit-content; max-width:100%">
                <h2>HLSL Constant Buffer Packing Rules</h2>
            </div>
            <div class="article_width">
                <section>
                    <h3 id="Introduction">0. Introduction</h3>
                    <p>
                        Constant Buffers in HLSL have rather peculiar rules for how their individual members are laid out in memory.
                        These rules are very different from those for structures in C and C++ and very hard to practically impossible to implement in their type system.
                        This often leads to a lot of confusion and frustration when the corresponding struct layouts in the CPU and GPU code mismatch and data ends up in the wrong places as a result.
                        This article will teach you all the packing rules for constant buffers in HLSL for Direct3D 10 / Shader Model 4.0 or newer. <a href="#fn:DXC" id="fnref:DXC"><sup></sup></a>
                    </p>
                    <p>
                        Note that these rules are <em>not</em> the same as for HLSL Structured Buffers (which are pretty much equal to C) or GLSL uniform buffers (called "std140 layout").
                        I will compare and contrast with those where appropriate, but explaining all the rules for different languages/buffer types from scratch is beyond the scope of this article.
                        If you want to play around with your own constant buffers and confirm their memory layout, click the big button above (code editor not supported on mobile browsers).
                        There is a similar visualization available for C++ in
                        <a href="https://devblogs.microsoft.com/visualstudio/size-alignment-and-memory-layout-insights-for-c-classes-structs-and-unions/">Visual Studio 2022 version 17.9</a> (currently in preview as of 2024-02-05).
                    </p>
                    <p>
                        <b>Update (2024-02-05):</b> Structured Buffers are now supported in the visualizer and I have added a <a href="#Structured_Buffers">short explanation of the rules to the end of the article</a>,
                        including how they <em>can</em> differ from the rules for C structs depending on the target platform.
                    </p>
                    <p>
                        Let's start by defining what <dfn>alignment</dfn> means.
                        We say a memory address is "aligned to <var>N</var>" if it is evenly divisible by <var>N</var>, or in other words if the address is an integer multiple of <var>N</var>.
                        If a type "has an alignment [requirement] of <var>N</var>" then an instance of it must always start at a memory address aligned to <var>N</var>. The alignment <var>N</var> is always a power of two.
                    </p>
                    <p>
                        In HLSL, we do not have access to memory addresses / pointers, so for our purpose of defining the layout of a constant buffer,
                        we only need to care about the offset in bytes from the start of the buffer that is assigned to each member. <a href="#fn:cbuffer-alignment" id="fnref:cbuffer-alignment"><sup></sup></a>
                        The definitions of alignment work equivalently for that offset.
                        In order to maintain proper alignment for all members of a struct/buffer, it may be necessary to add invisible <dfn>padding</dfn> bytes in between them.
                    </p>
                    <p></p>
                    <div id="CBV_color_theme_controls_inline_container"><i>If you have trouble reading the examples, here are some controls for the colors and a theme switch for the whole site:</i><br /></div>
                    <p></p>
                </section>
                <section>
                    <h3 id="Type_Alignment">1. Type Alignment</h3>
                    <p class="rule_definition" id="rule1">
                        <b>Rule #1</b>: Basic scalar types such as <code>float</code>, <code>uint</code>, <code>uint16_t</code>, etc. have a "natural" alignment requirement equal to their size. This is also called "self-alignment".
                        <br /><b>Note</b>: <code>bool</code> in HLSL is 4 bytes large!
                    </p>
                    <!-- NOTE: formatting doesn't matter here, we auto-format when we replace this with the actual visualization -->
                    <div class="CBV_example">
                        cbuffer ExampleScalarAlignment {
                        uint16_t smol;
                        float f1;
                        float f2;
                        double lorg;
                        bool four_bytes;
                        };
                    </div>
                    <p>
                        <i>You can mouse over the colored struct members or the rectangles to highlight the individual elements.</i>
                    </p>
                    <p>
                        In the example above, there are 2 bytes of padding added after <code>smol</code> in order to align <code>f1</code> properly to a multiple of 4.
                        Similarly, <code>lorg</code> cannot start at an offset of 12 since that would not be an integer multiple of its alignment 8, resulting in an additional 4 bytes of padding in between <code>f2</code> and <code>lorg</code>.
                    </p>
                    <p>
                        It's pretty rare to use the 2 or 8 byte large scalar types in HLSL, but this is the most fundamental alignment rule.
                        It is common across most programming languages and target platforms because many processor architectures require the memory address of a load or store instruction to be aligned to the size of the load/store (x86 being one of the biggest exceptions).
                        Misaligned addresses may result in either a CPU exception, unexpected results (e.g. the processor may round the address down to the nearest aligned one and thus load different data) or in some cases slower execution.
                        This is why type self-alignment is very fundamental for program correctness and performance, so we make this our first rule, as it's practically universal.
                    </p>
                    <p>
                        Tip: If you need to supply a <code>bool</code> to HLSL in any buffer type, use an actual 4 byte type on the CPU code side (e.g. <code>windows.h</code>'s <code>BOOL</code>, <code>uint32_t</code> or your own for C/C++).
                        Do <em>not</em> use <code>alignas(4) bool</code> or manual padding (e.g. <code>bool b; char[3] pad;</code>) because you do not always have the guarantee that the internal padding bytes are zeroed out,
                        but they will actually be read by the shader regardless and thus your boolean could produce a <code>true</code> value when it shouldn't!
                    </p>
                    <p>
                        For the sake of completeness, the minimum-precision types (<code>min10/16*</code>) and <code>half</code> have a storage size (and thus alignment) in memory of 4 bytes by default, even though the driver compiler is
                        allowed to emit lower precision ALU instructions for the min-precision types (not <code>half</code>, which is directly mapped to <code>float</code>). When you enable native 16-bit type support via the
                        <code>-enable-16bit-types</code> command line argument to DXC, all of those types including <code>half</code> turn into actual 16-bit types like <code>(u)int16_t</code> or <code>float16_t</code> and have a corresponding
                        size and alignment of 2 bytes, as in the examples. There are no types smaller than 4 bytes in HLSL without using DXC and this command line flag. <a href="#fn:16-bit-types" id="fnref:16-bit-types"><sup></sup></a>
                    </p>
                    <p class="rule_definition" id="rule1a">
                        <b>Rule #1a</b>: Vector types are aligned according to their scalar component type.
                    </p>
                    <div class="CBV_example">
                        cbuffer ExampleVectorAlignment {
                        float f1;
                        float3 vec;
                        uint3 other_vec;
                        float f2;
                        float16_t smol;
                        int2 intvec;
                        };
                    </div>
                    <p>
                        This is the first rule that might bring some surprise, especially if you are familiar with GLSL uniform buffers / std140, where a <code>vec3</code> (equivalent to <code>float3</code>) would have an alignment of 16.
                        This is <em>not</em> the case in HLSL.
                        The first four members in this example all have an alignment requirement of 4 and they can all be neatly packed together, it also doesn't matter that some of them are <code>float</code>s and some are <code>uint</code>s.
                        Just like in the first example, we do incur some padding when a smaller type is followed by a larger one, but while the size of <code>intvec</code> is 8, it's alignment requirement is only 4 (based on its scalar type),
                        so only 2 bytes of padding are needed.
                    </p>
                    <p>
                        The rules we've covered so far are the only ones that deal with <dfn>type alignment</dfn> in constant buffers.
                        All of the following rules are entirely unique to constant buffers and only involve <dfn>variable alignment</dfn>. I'll explain the difference between these two terms as we cover more rules and examples.
                    </p>
                </section>
                <section>
                    <h3 id="Buffer_Rows">2. Buffer Rows</h3>
                    <p class="rule_definition" id="rule2">
                        <b>Rule #2</b>: A Constant Buffer is arranged conceptually like an array of 16-byte rows.
                        The members of the buffer are packed into these rows and if an individual member would cross the boundary between two rows, its starting offset is forcibly aligned to 16 bytes,
                        pushing it to the start of the next row if it isn't already aligned.
                    </p>
                    <div class="CBV_example">
                        cbuffer ExampleBufferRows {
                        float3 position;
                        float3 normal;
                        uint index;
                        double4 d;
                        };
                    </div>
                    <p>
                        <i>This rule explains why I chose the visual memory layout diagrams to be in rows of 16 bytes.</i>
                    </p>
                    <p>
                        In this example, two <code>float3</code> members next to each other incur 4 bytes of padding in between, but this is <em>not</em> because of the inherent alignment requirement of their type (which is still 4).
                        The padding results purely from crossing a 16-byte row boundary within the buffer. It is only dependent on the size of a member and its initially desired starting offset,
                        or effectively the <em>sequence</em> of member types in the buffer. This rule does not confer alignment to a type, but to a specific individual member variable and is thus no longer a <em>type alignment</em> rule.
                        <code>normal</code> has a desired offset of 12, right at the end of <code>position</code>, but it is forcibly pushed to start at offset 16 because it does not fit entirely into the rest of the first 16-byte row.
                    </p>
                    <p>
                        The member <code>index</code> is packed directly after <code>normal</code> with no padding and is here to demonstrate again that <code>float3</code> does <em>not</em> actually have a type alignment of 16,
                        otherwise the size of the type itself would have to be padded to 16 as well. In C-like struct packing, the size of a type must always be an integer multiple of its alignment.
                        Otherwise, an array of that type would misalign its elements and a struct containing an overaligned type would have its layout depend on its starting address.
                        This common rule <em>never</em> applies to types inside constant buffers because those specific problems with arrays and structs are already solved in other ways, which we will see further below in rules #3 and #4,
                        but let's not get ahead of ourselves.
                        The <code>double4</code> variable is too large for one row even just by itself, but its starting offset is already aligned to 16 bytes without any modification, so it stays where it is.
                    </p>
                    <p>
                        The row-packing rule is probably the most confusing of them all, because only looking at the offsets may imply an increased type alignment where there is none.
                        In other languages, aligning individual variables is usually only relevant for allocating entire buffers when you do SIMD work or want cache or page alignment for other reasons.
                        HLSL is very much the odd one out with its "array of 16-byte aligned rows" design for constant buffers that affects individual struct members, so it takes some time to get used to it.
                        <a href="#fn:cbuffer-history" id="fnref:cbuffer-history"><sup></sup></a>
                    </p>
                    <p>
                        I usually recommend manually padding out structs in C++ and equivalently in HLSL for consistency, instead of trying to emulate this behavior with <code>alignas(16)</code>
                        (which can do either variable or type alignment depending on where you put it). For example, you could put <code>uint32_t pad0;</code> after <code>float3 position;</code>.
                        Since the 4 byte scalar types and their vectors are a large majority of constant buffer usage (apart from matrices, which we'll get to later), it can help to conceptually think of
                        your buffer as an array of <code>float4/uint4</code> elements and then assign "slots" for individual variables within those elements, leaving anything that isn't assigned as padding.
                    </p>
                    <p>
                        Minimum-precision types (<code>min10/16*</code>) have weird interactions with this rule when native 16-bit types are <em>not</em> enabled. In that case, min-precision types cannot be packed
                        together with regular fixed-precision types in the same row. My opinion: just don't use them.
                    </p>
                </section>
                <section>
                    <h3 id="Arrays_and_Matrices">3. Arrays and Matrices</h3>
                    <p class="rule_definition" id="rule3">
                        <b>Rule #3</b>: Each element of an array starts a new 16-byte row, i.e. its starting offset is forcibly aligned to the next 16 byte boundary.
                    </p>
                    <div class="CBV_example">
                        cbuffer ExampleArrays {
                        float2 before;
                        float array[2];
                        float2 after;
                        };
                    </div>
                    <p>
                        <i>The individual array elements are expanded in this visualization to help clarify the layout. The resulting syntax isn't a legal struct declaration anymore.</i>
                    <p>
                        This is one of the big pain points of constant buffers. Arrays are not packed tightly and instead must start a new 16-byte row for each element so that array indexing happens on a per-row basis,
                        leading to potentially huge gaps in between array elements.
                        This can be worked around by using larger element types (e.g. <code>float4 arr[4]</code> instead of <code>float arr[16]</code>), but then you have to use 2D indexing with division and modulo
                        (e.g. <code>arr[i / 4][i % 4]</code> or equivalently <code>arr[i >> 2][i &amp; 3]</code>) which can then <em>hopefully</em> be optimized out once you go through the driver compiler
                        (unlikely with a value only known at runtime).
                        Note that as before, we are not increasing the elements' type alignment and not increasing the size of them to full rows, we are just aligning their starting offset as if they were individual variables,
                        so the total size of <code>array</code> in this example is 20 bytes and the member <code>after</code> can be packed right at the end of the array with no additional padding.
                    </p>
                    <p>
                        This is annoying to deal with in C++, because if the elements do not have a size divisible by 16, you would have to do away with the array and put them as individual variables with either
                        added variable alignment via <code>alignas(16)</code> or manual padding before and in between (but not at the end!). You could also increase the size/alignment of the element type
                        (e.g. making an array of padded structs), but then you have to make sure to add padding after the array on the HLSL side because it only adds it <em>in between</em> the array elements.
                        None of these options are particularly great.
                    </p>
                    <p class="rule_definition" id="rule3a">
                        <b>Rule #3a</b>: Matrices are laid out equivalently to arrays of column vectors (row vectors for row-major matrices). Hence, the array size is the number of columns (rows for row-major) and the vector size is the number of rows (columns).
                        <br /><b>Exception</b>: Matrices with only one column (row for row-major) are layout-equivalent to a simple vector, not an array of one vector (i.e. they do not incur the extra 16 byte row alignment).
                        <br /><b>Note</b>: The HLSL type is always <code>typeRxC</code> with <code>R</code> being the number of rows and <code>C</code> being the number of columns
                        (matches math notation, but reverse order of GLSL/GLM's <code>matCxR</code>) and the default storage order is column-major. <a href="#fn:matrix-order" id="fnref:matrix-order"><sup></sup></a>
                    </p>
                    <div class="CBV_example">
                        cbuffer ExampleMatrices {
                        float2 before;
                        float2x3 mat;
                        float2x1 smol_mat;
                        };
                    </div>
                    <p>
                        <i>Matrices are converted into their layout-equivalent types in this visualization because it makes my job easier.</i>
                    </p>
                    <p>
                        Thankfully, matrices just collapse down to the types and rules we've already learned about, with the only slightly tricky part being one-column matrices
                        (note how <code>smol_mat</code> does not need to be 16-byte aligned, though those matrix dimensions do not seem particularly useful).
                        The matrix <code>mat</code> turns into an array of three <code>float2</code> vectors and we incur the excessive padding cost of arrays just as in the previous example.
                        It would be worth it to split this into three individual <code>float2 colN</code> variables to save 24 bytes of padding, though I should note that when later reconstructing the matrix in the shader,
                        HLSL always expects rows in the constructor and not columns, no matter which storage order you chose.
                    </p>
                    <p>
                        <i>
                            I realize that the term "row" from <a href="#rule2">Rule #2</a> concerning the 16-byte boundaries within the buffer is now overloaded with matrix rows/columns, but what can you do.
                        </i>
                    </p>
                </section>
                <section>
                    <h3 id="Inner_Structs">4. Inner Structs</h3>
                    <p class="rule_definition" id="rule4">
                        <b>Rule #4</b>: Inner/nested structs must start at a 16-byte aligned offset.
                    </p>
                    <div class="CBV_example">
                        cbuffer ExampleInnerStructs {
                        float2 before;
                        struct Inner_t {
                        float start;
                        double d;
                        float end;
                        } inner;
                        float3 after;
                        };
                    </div>
                    <p>
                        Similar to array elements, inner struct variables are always forcibly aligned to start a new buffer row. As a result, we have some padding before the start of the struct in this example.
                        All the previous rules still apply within the inner struct, in this case the self-alignment requirement for <code>d</code> dictates 4 bytes of padding so it can start at an offset divisible by 8.
                    </p>
                    <p>
                        Of particular note here is that in C (and structured buffers), a struct has a type alignment equivalent to the largest alignment requirement of any of its members.
                        This is to ensure all members are automatically aligned properly when the struct is constructed at an address conforming to the struct's type alignment (also including arrays of structs).
                        If we implemented this example in C, <code>Inner_t</code> would have an alignment of 8 because of the <code>double</code> sub-member and thus a size of 24
                        (the size must be a multiple of its type alignment, leading to 4 bytes of padding at the end inside the struct).
                    </p>
                    <p>
                        This is <em>not</em> the case in HLSL constant buffers. Since the start of any struct is always forcibly aligned to 16 bytes and 16 is larger than any possible
                        type alignment requirement in HLSL, the concern of having members misaligned is nonexistent and the struct type itself never has any padding before the end to account for some inherent type alignment
                        (structs effectively have no type alignment of their own, it's all handled by the forced row alignment).
                        In fact, no type inside a constant buffer can have padding at the start or end within itself that would count towards its size, any padding is always <em>in between</em> variables or array elements.
                        Thus, <code>Inner_t</code> has a size of 20 and <code>after</code> can fit snugly in the remaining 12 bytes of the last buffer row
                        (remember that if it crossed a 16-byte row boundary it would be pushed to start at the next row in accordance with <a href="#rule2">Rule #2</a>).
                    </p>
                    <p>
                        This also means that this particular struct layout is very hard to implement in the C or C++ type system. You would first have to align the struct variable (not the type!) and then use your compiler's
                        equivalent of <code>__attribute__((packed))</code> to forcibly remove the padding at the end of the struct, but then also add back any padding in between the sub-members. This ends up very brittle and confusing to read.
                        It might be better to massage the HLSL side into something that is easier to translate to C
                        (I will note again that the use of anything other than 4 byte types is rare in HLSL, but I do need to explain the rules regardless).
                    </p>
                    <p>
                        Another consequence of this rule is that the memory layout within the inner struct is effectively independent of where it is in the buffer, because all the constant buffer rules work in alignments of 16 or smaller,
                        so the struct layout is the same whether the start offset is 0 or any other integer multiple of 16.
                        The mentioned "struct alignment equals the largest member alignment" rule for C similarly ensures the same layout independence of starting location, but in a more "fine-grained" way.
                    </p>
                </section>
                <section>
                    <h3 id="Sources_and_Methodology">5. Sources and Methodology</h3>
                    <p>
                        I based the rules in this article on the following original sources:
                    </p>
                    <ul>
                        <li>
                            <a href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-packing-rules">Packing Rules for Constant Variables (HLSL Reference, Microsoft Learn)</a>
                        </li>
                        <li>
                            <a href="https://github.com/microsoft/DirectXShaderCompiler/wiki/Buffer-Packing">Alignment and Buffer Packing (Microsoft DXC GitHub Wiki)</a>
                        </li>
                    </ul>
                    <p>
                        In addition, I checked all the rules and possibly ambiguous cases using DXC and sometimes FXC. DXC is easily accessible via <a href="https://hlsl.godbolt.org/">Compiler Explorer</a>.
                        To check a buffer's layout on Compiler Explorer, you must first use it in the shader function in some way (any contrived usage will do, it just needs to not be optimized out) and then disable filtering
                        comments on the compiler output tab. Those comments show buffer layouts, resource bindings and a few other things. Also useful: you can check the actual GPU instructions emitted for AMD GPUs by switching
                        to the RGA (Radeon GPU Analyzer) compiler (this might not be 100% accurate to live testing due to differences in driver versions and because Compiler Explorer passes the shader to RGA via the SPIR-V
                        backend of DXC).
                    </p>
                </section>
                <section>
                    <h3 id="Structured_Buffers">6. Addendum (2024-02-05): Structured Buffers and C Structs</h3>
                    <p>
                        I was originally not going to write about Structured Buffers, but I ended up adding support to the visualizer anyways and all the relevant rules have already been briefly mentioned in the chapters above.
                    </p>
                    <h4>Rules for HLSL Structured Buffers:</h4>
                    <ol class="rule_definition list_justified_spaced">
                        <li>All scalar types are self-aligned, i.e. their type alignment requirement is equal to their size. <br /><b>Note:</b> <code>bool</code> has a size of 4 bytes in HLSL.</li>
                        <li>Vectors and matrices are aligned according to their scalar component type.</li>
                        <li>Structures have a type alignment equal to the largest alignment among all of their members. <a href="#fn:struct-variable-alignment" id="fnref:struct-variable-alignment"><sup></sup></a></li>
                        <li>
                            The size of a type must be an integer multiple of its type alignment. Types not naturally conforming to this rule will be padded at the end to enforce it.
                            You could say this is the "stride" of a type in an array.
                            <br /><b>Note:</b> There are no overaligned types (alignment > size) in HLSL and no way to create them (no <code>alignas</code>), so this only ever applies to structs.
                        </li>
                        <li>
                            Array elements are instances of the element type and must therefore obey the above rules for their type alignment.
                            Beyond that, arrays are packed tightly and do not impose any additional alignment rules or padding on top.
                        </li>
                    </ol>
                    <p>
                        Overall it's quite simple compared to Constant Buffers. Arrays, vectors and matrices really just fall back to the scalar and struct alignment rules, the extra rules for them are not technically needed
                        and are just here for clarity. Padding can only happen if a larger type follows a smaller type or at the end of a struct to pad its size to a multiple of its alignment.
                    </p>
                    <p>
                        These same rules generally also apply to structs in C, C++ and other languages with C-like packing (apart from the HLSL-specific notes). However, the size of some types may differ from platform to platform
                        (e.g. <code>int</code>, <code>float</code> or <code>bool</code>) and sometimes types are not even self-aligned. The most prominent example for non-self-alignment would be
                        32-bit x86 Linux-based targets, where <code>double</code> has a size of 8, but only an alignment of 4.
                        There are many other architectures with uncommon type sizes, formats or alignments, but they're usually embedded systems, 8- or 16-bit and/or DSPs, so not particularly relevant to look at for HLSL programming.
                        Apart from potentially 32-bit x86 Linux, there are probably no platforms anyone would write HLSL code for where equivalently defined C structs and Structured Buffers differ in their memory layout,
                        outside of the <code>bool</code> type being a different size.
                        I will not discuss bitfields here because the rules differ by compiler, platform and language standard and I'm not even sure how they match up with HLSL 2021, use at your own risk.
                    </p>
                    <p>
                        Let's do one example covering the rules above:
                    </p>
                    <div class="CBV_example">
                        struct ExampleSB {
                        float before;
                        struct Inner_t {
                        float start;
                        double lorg;
                        uint16_t u[2];
                        } inner;
                        float after;
                        };

                        StructuredBuffer&lt;ExampleSB&gt; ex;
                    </div>
                    <p>
                        The <code>double</code> member of the inner struct in this example not only needs to be aligned to a multiple of 8 itself, it is also the member with the largest alignment within the struct.
                        If we took the members out of the inner struct, <code>start</code> could be at offset 4, <code>lorg</code> could be at offset 8, etc. and we would in fact have <em>no padding at all</em> inside the entire buffer.
                        However, as a consequence of the third rule for structured buffers, the inner struct is also assigned a type alignment of 8 and it must start at offset 8 here, despite its first member not needing that strong of an alignment.
                        Thus, we need 4 bytes of padding before the struct and another 4 bytes before <code>lorg</code> to align them both correctly.
                    </p>
                    <p>
                        Arrays are thankfully tightly packed in this type of buffer, so we don't directly provoke any extra padding for <code>u</code>. Still, we need to pad out the inner struct to a multiple of its alignment,
                        hence we do end up with another extra 4 bytes after the array. The "largest member alignment" rule also goes for the outer struct, so it too is allotted an alignment of 8
                        (from the <code>inner</code> member, which itself inherited it from <code>lorg</code>) and we need to pad out the very end of the struct. This is important because structured buffers are conceptually arrays
                        of the type given in the template, so that padding at the end actually matters for the access stride.
                    </p>
                    <p>
                        This example is definitely an extreme case, usually there is very little if any padding at all in structured buffers given the common use cases and types used in HLSL, but since the rules for C/C++ are mostly the same,
                        this type of analysis can still be useful. As always, the examples are for illustrative purposes.
                    </p>
                </section>

                <hr />

                <aside>
                    <h3 id="Footnotes">Footnotes:</h3>
                    <ol class="list_justified_spaced">
                        <li id="fn:DXC">
                            The DXC compiler for D3D12 technically offers a command line flag to disable the "legacy" constant buffer layout rules,
                            but no graphics driver can actually interpret the resulting shader correctly, so it is unusable until we get a new shader model update formalizing the specifications and support properly.
                            <a href="#fnref:DXC">↩</a>
                        </li>
                        <li id="fn:cbuffer-alignment">
                            Constant buffers themselves are always aligned to <em>at least</em> 256 bytes, which is a much larger alignment than we will ever need to consider within it.
                            <a href="#fnref:cbuffer-alignment">↩</a>
                        </li>
                        <li id="fn:16-bit-types">
                            There is a full table of scalar types and what they map to depending on command line flags available here: <a href="https://github.com/microsoft/DirectXShaderCompiler/wiki/16-Bit-Scalar-Types">16 Bit Scalar Types (Microsoft DXC GitHub Wiki)</a>.
                            <a href="#fnref:16-bit-types">↩</a>
                        </li>
                        <li id="fn:cbuffer-history">
                            The historic reason for this design is that shader constants used to be supplied via individual vector registers, not actual buffer resources, so the 16 byte rows here are the equivalent
                            of <code>float4</code> vector registers. The point is to pack the members so that a load of a single variable does not cross from one "register" to the other
                            and indexing is always done on a register-to-register basis too, not <em>within</em> a register (this will bite us hard with arrays later).
                            FXC does actually accept constant buffer struct syntax for D3D9 / Shader Model 3.0 or older, but each
                            individual member is simply put into a subsequent <code>float4</code>-sized constant register as if they were entirely unrelated variables, there is no packing at all.
                            There was no API support beyond setting the value of an individual register either (unless you count the helper library D3DX9, which just sets the registers for you under the hood).
                            This may also be related to why constant buffers declared via the <code>cbuffer</code> keyword still do not namespace their member variables without adding an inner struct.
                            <a href="#fnref:cbuffer-history">↩</a>
                        </li>
                        <li id="fn:matrix-order">
                            If you would like to firmly put your palm on your forehead, see <a target="_blank" href="HLSL%20matrix%20storage%20order.png">this table</a>
                            on how to (not) set a different default matrix storage order in the two major HLSL compilers. Basically, adding <code>/Zpr</code> to the command line arguments of FXC changes matrices contained within structs
                            or constant buffers to row-major, but <em>not</em> structured buffers that directly contain just a matrix (e.g. <code>StructuredBuffer&lt;float4x4&gt;</code>).
                            The <code>/Zpr</code> flag for DXC however changes <em>all</em> matrices to row-major. To emulate the old FXC behavior, DXC added <code>#pragma pack_matrix(row_major)</code> to put in your code.
                            This pragma also allows you to complete the confusion by using <code>/Zpr</code> (changes all matrices to row-major) and then also <code>#pragma pack_matrix(column_major)</code> to only change matrices
                            contained within structs or cbuffers back to column-major.
                            <a href="#fnref:matrix-order">↩</a>
                        </li>
                        <li id="fn:struct-variable-alignment">
                            The "largest alignment" does count type alignment as well as variable alignment. There is no way to manually assign any kind of alignment in HLSL as of yet, so it isn't really important,
                            but it is possible in C++, so I wanted to mention it at least in a footnote.
                            For example, <code>struct { alignas(32) int i; };</code> would make the struct have a type alignment and size of 32 even though the <code>int</code> type itself has no modified alignment here.
                            For completeness, the syntax for assigning a (larger) type alignment to a struct would be <code>struct alignas(N) type { ... }</code>, while aligning an individual variable/member would look like <code>alignas(N) struct type { ... } name;</code>.
                            <a href="#fnref:struct-variable-alignment">↩</a>
                        </li>
                    </ol>
                </aside>

                <template id="CBV_example_template">
                    <div class="CBV_example_container">
                        <div class="CBV_left">
                            <text class="code" id="CBV_example_input"></text>
                        </div>
                        <div class="CBV_middle">
                            <text id="CBV_example_output_text" class="code">
                            </text>
                        </div>
                        <div class="CBV_right">
                            <svg id="CBV_example_output_svg" class="code">
                            </svg>
                        </div>
                    </div>
                </template>

                <script type="module">
                    import { ParseHLSLAndVisualizeTextNode, BufferVisualizerList, BufferVisualizerOptionsDefault } from './main.js';

                    // scale down SVG rects on very narrow screens
                    const GetRectScale = () => {
                        let example = document.querySelector(".CBV_example");
                        let container_width = parseFloat(window.getComputedStyle(example).width) - 16 /* padding */;
                        let default_rect_width = 16 * BufferVisualizerOptionsDefault.svg_width_per_byte;
                        let rect_scale = Math.max(Math.min(container_width / default_rect_width, 1.0), 0.75);
                        return rect_scale;
                    };

                    window.addEventListener("resize", () => {
                        window.CBV_ExampleVisualizers?.SetSVGWidthPerByte(GetRectScale() * BufferVisualizerOptionsDefault.svg_width_per_byte);
                    }, { passive: true });

                    window.CBV_ExampleVisualizers = new BufferVisualizerList();
                    let examples = document.querySelectorAll(".CBV_example");
                    let options = window.GetVisualizerOptions();
                    options.check_matches_c_layout = false;
                    options.text_alignment_min = 24;
                    options.text_alignment_offset = 1;
                    options.color_shuffle = false;
                    options.expanded_arrays = true;
                    options.text_indent_width = 3; // NOTE: make sure we don't overflow the horizontal layout with fonts wider than Consolas
                    options.svg_width_per_byte *= GetRectScale();

                    // set up all examples with the template
                    for (let i = 0; i < examples.length; i++) {
                        let options_clone = Object.assign({}, options); // clone options because they're logically supposed to be separate objects
                        let clone = CBV_example_template.content.cloneNode(true);
                        let input = clone.querySelector("#CBV_example_input");
                        let output_text = clone.querySelector("#CBV_example_output_text");
                        let output_svg = clone.querySelector("#CBV_example_output_svg");
                        input.id = input.id + i;
                        output_text.id = output_text.id + i;
                        output_svg.id = output_svg.id + i;
                        input.textContent = examples[i].textContent;
                        examples[i].replaceChildren(clone);
                        window.CBV_ExampleVisualizers.Push(ParseHLSLAndVisualizeTextNode(input, output_text, output_svg, options_clone));
                    }

                </script>
            </div>
        </article>
    </main>
    <footer class="article_width" style="text-align:center">
        <hr style="margin-top:16px; margin-bottom:16px" />
        <p>
            Copyright &copy; 2024 Maraneshi
        </p>
        <a href="https://twitter.com/maraneshi" style="padding:8px;"><svg xmlns="http://www.w3.org/2000/svg" height="48" width="48" viewBox="0 0 512 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path fill="#A0A0F4" d="M459.4 151.7c.3 4.5 .3 9.1 .3 13.6 0 138.7-105.6 298.6-298.6 298.6-59.5 0-114.7-17.2-161.1-47.1 8.4 1 16.6 1.3 25.3 1.3 49.1 0 94.2-16.6 130.3-44.8-46.1-1-84.8-31.2-98.1-72.8 6.5 1 13 1.6 19.8 1.6 9.4 0 18.8-1.3 27.6-3.6-48.1-9.7-84.1-52-84.1-103v-1.3c14 7.8 30.2 12.7 47.4 13.3-28.3-18.8-46.8-51-46.8-87.4 0-19.5 5.2-37.4 14.3-53 51.7 63.7 129.3 105.3 216.4 109.8-1.6-7.8-2.6-15.9-2.6-24 0-57.8 46.8-104.9 104.9-104.9 30.2 0 57.5 12.7 76.7 33.1 23.7-4.5 46.5-13.3 66.6-25.3-7.8 24.4-24.4 44.8-46.1 57.8 21.1-2.3 41.6-8.1 60.4-16.2-14.3 20.8-32.2 39.3-52.6 54.3z" /></svg></a>
        <a href="https://mastodon.gamedev.place/@Maraneshi" style="padding:8px;"><svg xmlns="http://www.w3.org/2000/svg" height="48" width="48" viewBox="0 0 448 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path fill="#A0A0F4" d="M433 179.1c0-97.2-63.7-125.7-63.7-125.7-62.5-28.7-228.6-28.4-290.5 0 0 0-63.7 28.5-63.7 125.7 0 115.7-6.6 259.4 105.6 289.1 40.5 10.7 75.3 13 103.3 11.4 50.8-2.8 79.3-18.1 79.3-18.1l-1.7-36.9s-36.3 11.4-77.1 10.1c-40.4-1.4-83-4.4-89.6-54a102.5 102.5 0 0 1 -.9-13.9c85.6 20.9 158.7 9.1 178.8 6.7 56.1-6.7 105-41.3 111.2-72.9 9.8-49.8 9-121.5 9-121.5zm-75.1 125.2h-46.6v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.3V197c0-58.5-64-56.6-64-6.9v114.2H90.2c0-122.1-5.2-147.9 18.4-175 25.9-28.9 79.8-30.8 103.8 6.1l11.6 19.5 11.6-19.5c24.1-37.1 78.1-34.8 103.8-6.1 23.7 27.3 18.4 53 18.4 175z" /></svg></a>
        <a href="https://maraneshi.bsky.social" style="padding:8px;"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="48" width="48" viewBox="0 0 600 530"><path fill="#A0A0F4" d="m135.72 44.03c66.496 49.921 138.02 151.14 164.28 205.46 26.262-54.316 97.782-155.54 164.28-205.46 47.98-36.021 125.72-63.892 125.72 24.795 0 17.712-10.155 148.79-16.111 170.07-20.703 73.984-96.144 92.854-163.25 81.433 117.3 19.964 147.14 86.092 82.697 152.22-122.39 125.59-175.91-31.511-189.63-71.766-2.514-7.3797-3.6904-10.832-3.7077-7.8964-0.0174-2.9357-1.1937 0.51669-3.7077 7.8964-13.714 40.255-67.233 197.36-189.63 71.766-64.444-66.128-34.605-132.26 82.697-152.22-67.108 11.421-142.55-7.4491-163.25-81.433-5.9562-21.282-16.111-152.36-16.111-170.07 0-88.687 77.742-60.816 125.72-24.795z" /></svg></a>
        <a href="https://twitch.tv/maraneshi" style="padding:8px;"><svg xmlns="http://www.w3.org/2000/svg" height="48" width="48" viewBox="0 0 512 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path fill="#A0A0F4" d="M391.2 103.5H352.5v109.7h38.6zM285 103H246.4V212.8H285zM120.8 0 24.3 91.4V420.6H140.1V512l96.5-91.4h77.3L487.7 256V0zM449.1 237.8l-77.2 73.1H294.6l-67.6 64v-64H140.1V36.6H449.1z" /></svg></a>
        <a href="https://github.com/maraneshi" style="padding:8px;"><svg xmlns="http://www.w3.org/2000/svg" height="48" width="48" viewBox="0 0 496 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path fill="#A0A0F4" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3 .3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5 .3-6.2 2.3zm44.2-1.7c-2.9 .7-4.9 2.6-4.6 4.9 .3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3 .7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3 .3 2.9 2.3 3.9 1.6 1 3.6 .7 4.3-.7 .7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3 .7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3 .7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z" /></svg></a>
        <a href="https://buymeacoffee.com/maraneshi" style="padding:8px;"><svg xmlns="http://www.w3.org/2000/svg" height="48" width="48" viewBox="0 0 512 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path fill="#A0A0F4" d="M169.7 .9c-22.8-1.6-41.9 14-47.5 34.7L110.4 80c.5 0 1.1 0 1.6 0c176.7 0 320 143.3 320 320c0 .5 0 1.1 0 1.6l44.4-11.8c20.8-5.5 36.3-24.7 34.7-47.5C498.5 159.5 352.5 13.5 169.7 .9zM399.8 410.2c.1-3.4 .2-6.8 .2-10.2c0-159.1-128.9-288-288-288c-3.4 0-6.8 .1-10.2 .2L.5 491.9c-1.5 5.5 .1 11.4 4.1 15.4s9.9 5.6 15.4 4.1L399.8 410.2zM176 208a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm64 128a32 32 0 1 1 64 0 32 32 0 1 1 -64 0zM96 384a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z" /></svg></a>
    </footer>
    <!-- extra screen height so that the footnote links put you in the right place -->
    <div style="height:calc(100vh - (1.3em * 7));"></div>
</body>
</html>